; Escribir el código en assembler de DLX que ejecute las siguientes operaciones: a = b + c y d = e – f
; en donde a, b, c, d, e, f son variables de 4 bytes almacenadas consecutivamente en memoria a partir de la
; dirección 0x64 según se muestra en la figura. La variable a = a3 a2 a1 a0 en donde a3 es el byte más
; significativo y a0 el menos significativo; lo mismo para las otras variables.

	.data 0x64
	;comienzo de los datos
a:	.space	4 ; reservo 4 bytes para el resultado a
b:	.word	150
c:	.word	3480
d:	.space	4 ; reservo 4 bytes para el resultado d
e:	.word	4500
f:	.word	400
	.text	0x100
	; comienzo del código
	LW		r2, b(r0)	; |b3| b2| b1| b0| r2 <- b ayuda -> b(r0) = dirección_de_b + 0 = 0x68
	LW		r3, c(r0)	; |c3| c2| c1| c0| r3 <- c
	ADD		r4, r2, r3	; r4 <- b + c
	SW		a(r0), r4	; a <- r4
	LW		r2, e(r0)	; |e3| e2| e1| e0| r2 <- e
	LW		r3, f(r0)	; |f3| f2| f1| f0| r3 <- f
	SUB		r4, r2, r3	; r4 <- e - f
	SW		d(r0), r4	; d <- r4
	TRAP	0


; Calcular el valor máximo de un arreglo de 10 números de 32 bits almacenados en memoria a partir de la
; dirección 500H. Usar el registro r1 para almacenar el máximo, r2 para contener el candidato a máximo y r5
; como contador del iterar. Guardar el resultado al final del arreglo, indicando esta posición de memoria por la
; etiqueta “mayor”.
; Escribir el código en assembler de DLX con las directivas del programa ensamblador que ejecute dicha tarea.

			.data 0x500 			; carga del puntero de datos
			;carga de los datos en memoria a partir de 0x500
inicio: 	.word 150,45,-3,478,32,-56,-70,608,89,145
mayor: 		.space 4 				; reserva de 4 bytes para el resultado
			.text 0x1000 			; carga del puntero de texto
			;carga del código en memoria a partir de 0x1000
main: 		ADDI r7, r0, #inicio 	; r7 apunta al primer dato (r7) = 0x500 en r7
			LW r1, 0(r7) 			; r1 <- 1º dato
			ADDI r5, r0,#9 			; r5 es el contador del iterar (r5) = 9
otro: 		ADDI r7,r7,#4 			; incremento en 4 de r7 (apunta al próximo dato)
			LW r2,0(r7) 			; r2 <- próximo dato (candidato)
			SGT r3, r2, r1 			; si (r2) > (r1) then (r3) = 1
			BEQZ r3, no_mayor
			ADD r1, r2, r0 			; r1 <- r2
no_mayor: 	SUBI r5, r5,#1 			; decremento en 1 de r5
			BNEZ r5, otro
			SW mayor(r0), r1 		; almacen. del resultado en memoria SW mayor(r0) = dirección_de_mayor + 0
			TRAP 0

; Ejecutar las siguientes operaciones entre dos arreglos de datos [ai] y [bi] almacenados en memoria a partir de
; las direcciones 1000h y 2000h respectivamente. Cada arreglo posee 90 datos enteros de 4 bytes y la variable
; c es un valor entero de 4 bytes almacenado en memoria al final del arreglo [bi].
; [ai] = [bi] + c
; Escribir el código en assembler de DLX con las directivas del programa ensamblador que ejecute dicha tarea.
; Cargar el código a partir de la dirección 100h.

		.data 0x1000
a:		.space 360 				; reservo 360 bytes para los 90 elementos de [ai]
		.data 0x2000
b:		.word 10,20,30,35,40,45 ; los restantes 84 valores no están especificados para simplificar
c:		.word 459
		.text 0x100				; comienzo del código
main:	ADDI r2, r0, #0x1000 	; r2 apunta al vector [ai]
		LW r3, c(r0) 			; cargar en r3 la variable c -> c(r0) = dirección_de_c + 0
		ADDI r4, r0, #90 		; r4 es el contador de iterar
iterar: 	LW r5, 0x1000(r2) 		; cargar en r5 el elemento bi -> 0x1000(r2) = offsett de 1000 + direccion_r2
		ADD r6, r5, r3 			; r6 <- bi + c
		SW 0(r2), r6 			; almacenar el resultado r6 como el elemento ai
		ADDI r2, r2, #4 		; incremento de r2 en 4 para apuntar al próximo dato (elemento ai y bi).
		SUBI r4, r4, #1 		; decremento en 1 del contador de iterar.
		BNEZ r4, iterar
		TRAP 0

; Intercambiar las ubicaciones en memoria de dos arreglos de datos [ai] y [bi] de 32 bits y 15 elementos
; cargados en memoria a partir de las direcciones 1000h y 1200h respectivamente.

		.data 0x1000
a:		.word 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 ; arreglo [ai] de 15 elementos
		.data 0x1200
b:		.word 16,17,18,19,20,21,22,23,24,25,26,27,28,29,30 ; arreglo [bi] de 15 elementos
		.text 0x100				; comienzo del código
main:	ADDI r2, r0, #0x1000 	; r2 apunta al vector [ai]
		ADDI r3, r0, #0x1200 	; r3 apunta al vector [bi]
		ADDI r4, r0, #15 		; r4 es el contador de iterar
iterar: 	LW r5, 0(r2) 			; cargar en r5 el elemento ai
		LW r6, 0(r3) 			; cargar en r6 el elemento bi
		SW 0(r3), r5 			; almacenar el elemento ai en la posición de bi
		SW 0(r2), r6 			; almacenar el elemento bi en la posición de ai
		ADDI r2, r2, #4 		; incrementar r2 en 4 para apuntar al próximo dato (elemento ai).
		ADDI r3, r3, #4 		; incrementar r3 en 4 para apuntar al próximo dato (elemento bi).
		SUBI r4, r4, #1 		; decrementar en 1 el contador de iterar.
		BNEZ r4, iterar
		TRAP 0

; Intercambiar e invertir las ubicaciones en memoria de dos arreglos de datos [ai] y [bi], de manera que el
; primer dato de un arreglo pase a ser el último dato del otro arreglo y así sucesivamente hasta el final. Los
; arreglos son de 20 elementos de 32 bits y están cargados en memoria a partir de las direcciones 1000h y
; 1100h respectivamente.

		.data 0x1000
a:		.word 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20 ; arreglo [ai] de 20 elementos
		.data 0x1100
b:		.word 21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40 ; arreglo [bi] de 20 elementos
		.text 0x100				; comienzo del código
main:	ADDI r2, r0, #0x1000 	; r2 apunta al vector [ai]
		ADDI r3, #b, #20 		; r3 apunta al final del vector [bi] (1100h + 20*4 = 1140h)
		ADDI r4, r0, #20 		; r4 es el contador de iterar
iterar: 	LW r5, 0(r2) 			; cargar en	 r5 el elemento ai
		LW r6, 0(r3) 			; cargar en r6 el elemento bi (desde el final hacia el principio)
		SW 0(r3), r5 			; almacenar el elemento ai en la posición de bi
		SW 0(r2), r6 			; almacenar el elemento bi en la posición de ai
		ADDI r2, r2, #4 		; incrementar r2 en 4 para apuntar al próximo dato (elemento ai).
		SUBI r3, r3, #4 		; decrementar r3 en 4 para apuntar al próximo dato (elemento bi).
		SUBI r4, r4, #1 		; decrementar en 1 el contador de iterar.
		BNEZ r4, iterar
		TRAP 0
	


; Incrementar los elementos de un arreglo de datos [ai] de 32 bits de 10 elementos cargado en memoria a partir
; de la dirección 1050h en el valor de una constante c de 32 bits almacenada en memoria al final del arreglo.
; La operación a realizar es: [ai] <- [ai] + c.

			.data 0x1050
a:			.word 1,2,3,4,5,6,7,8,9,10	; arreglo [ai] de 10 elementos
c:			.word 5 					; constante c
			.text 0x100					; comienzo del código	
main:		ADDI r2, r0, #0x1050 		; r2 apunta al vector [ai]
			LW r3, c(r0) 				; cargar en r3 la constante c -> c(r0) = dirección_de_c + 0
			ADDI r4, r0, #10 			; r4 es el contador de iterar
iterar: 	LW r5, 0(r2) 				; cargar en r5 el elemento ai -> 0x1050(r2) = offsett de 1050 + direccion_r2
			ADD r6, r5, r3 				; r6 <- ai + c
			SW 0(r2), r6 				; almacenar el resultado r6 como el elemento ai
			ADDI r2, r2, #4 			; incremento de r2 en 4 para apuntar al próximo dato (elemento ai).
			SUBI r4, r4, #1 			; decremento en 1 del contador de iterar.
			BNEZ r4, iterar
			TRAP 0

; Mover (copiar) un arreglo de datos cargado en memoria a otra ubicación de memoria. El arreglo se encuentra
; a partir de la dirección 1300h y posee 18 elementos de 32 bits. Se desea moverlo a la ubicación de memoria
; que se encuentra a partir de la dirección 1600h.

			.data 0x1300
a:			.word 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18	; arreglo [ai] de 18 elementos
			.data 0x1600
b:			.space 72 				; reserva de 72 bytes para el arreglo [bi] (18*4=72)
			.text 0x100				; comienzo del código
main:		ADDI r2, r0, #a			; r2 apunta al vector [ai]
			ADDI r3, r0, #b			; r3 apunta al vector [bi]
			ADDI r4, r0, #18 		; r4 es el contador de iterar
iterar: 	LW r5, 0(r2) 			; cargar en r5 el elemento ai
			SW 0(r3), r5 			; almacenar el elemento ai en la posición de bi -> 0(r3) = direccion_r3 + offset 0
			ADDI r2, r2, #4 		; incrementar r2 en 4 para apuntar al próximo dato (elemento ai).
			ADDI r3, r3, #4 		; incrementar r3 en 4 para apuntar al próximo dato (elemento bi).
			SUBI r4, r4, #1 		; decrementar en 1 el contador de iterar.
			BNEZ r4, iterar
			TRAP 0


; Repetir el ejercicio 7 considerando que el arreglo posee 25 elementos de 1 byte.
			.data 0x1300
a:			.byte 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25 ; arreglo [ai] de 25 elementos
			.data 0x1600
b:			.space 25 				; reserva de 25 bytes para el arreglo [bi] (25*1=25)
			.text 0x100				; comienzo del código
main:		ADDI r2, r0, #a			; r2 apunta al vector [ai]
			ADDI r3, r0, #b			; r3 apunta al vector [bi]
			ADDI r4, r0, #25 		; r4 es el contador de iterar
iterar: 	LB r5, 0(r2) 			; cargar en r5 el elemento ai (1 byte)
			SB 0(r3), r5 			; almacenar el elemento ai en la posición de bi -> 0(r3) = direccion_r3 + offset 0
			ADDI r2, r2, #1 		; incrementar r2 en 1 para apuntar al próximo dato (elemento ai).
			ADDI r3, r3, #1 		; incrementar r3 en 1 para apuntar al próximo dato (elemento bi).
			SUBI r4, r4, #1 		; decrementar en 1 el contador de iterar.
			BNEZ r4, iterar
			TRAP 0


; Realice el seguimiento del siguiente código de programación en assembler del DLX para especificar cuál es
; la tarea que realiza y agregue las directivas para el programa ensamblador.

		ADDI r1, r0, #0x3000  		; Coloca en r1 la dirección inicial del bloque de memoria r1 = 0x3000
		ADDI r2,r0, #0				; Inicializa el acumulador r2 a 0
		ADDI r3, r0, #100		   ; Inicializa el contador r3 con el valor 100 (número de elementos a procesar)
Loop 	LW r4, 0(r1) 				; Carga en r4 el valor almacenado en la dirección apuntada por r1 -> r4 = Mem[0x3000 + offset]
		SGT r5, r4, #525		   ; Compara si r4 > 525, si es así r5 = 1, sino r5 = 0		
		BEQZ r5, salto				; Si r5 == 0 (r4 <= 525) salta a la etiqueta 'salto'
		ADD r2, r2, r4				; Si r4 > 525, acumula el valor de r4 en r2 -> r2 = r2 + r4
salto 	ADDI r1, r1, #4				; Incrementa r1 en 4 para apuntar al siguiente elemento (asumiendo que son palabras de 4 bytes)
		SUBI r3,r3,#1				; Decrementa el contador r3 en 1
		BNEZ r3, loop 				; Si r3 != 0, repite el ciclo
		SW 0(r1), r2				; Almacena el resultado en la dirección apuntada por r1 + offset -> Mem[0x3000 + offset] = r2
		TRAP 0
; Lo que realiza el programa es sumar todos los elementos de un bloque de memoria de 100 componentes que sean mayores a 525, para finalmente en la ultima componente de memoria almacenar la suma total.

; Codigo en directivas para el programa ensamblador.

			.data 0x3000
block:		.word  1,2,3, ...		; Aquí se deben definir o reservar los 100 elementos de memoria que se van a procesar.
			.text 0x100				; comienzo del código
main:		ADDI r1, r0, #block  	; Coloca en r1 la dirección inicial del bloque de memoria
			ADDI r2,r0, #0			; Inicializa el acumulador r2 a 0
			ADDI r3, r0, #100		; Inicializa el contador
Loop:		LW r4, 0(r1) 			; Carga en r4 el valor almacenado en la dirección apuntada por r1
			SGT r5, r4, #525		; Compara si r4 > 525
			BEQZ r5, salto			; Si r5 == 0 salta a la etiqueta 'salto'
			ADD r2, r2, r4			; Acumula el valor de r4 en r2
salto:		ADDI r1, r1, #4			; Incrementa r1 en 4 para apuntar al siguiente elemento
			SUBI r3,r3,#1			; Decrementa el contador r3 en 1
			BNEZ r3, loop 			; Si r3 != 0, repite el ciclo
			SW 0(r1), r2			; Almacena el resultado en la dirección apuntada por r1
			TRAP 0

; Realice el seguimiento del siguiente código de programación en assembler del DLX para especificar cuál es
; la tarea que realiza y agregue las directivas para el programa ensamblador.

		ADDI r1, r0, #0x5000	; Coloca en r1 la dirección inicial del bloque de memoria r1 = 0x5000
		ADDI r2, r0, #150		; Inicializa el contador r2 con el valor 150 (número de elementos a procesar)
		ADD r3, r0, r0			; Inicializa el acumulador r3 a 0
		ADDI r4, r0, #40		; Inicializa el límite superior r4 con el valor 40
		ADDI r5, r0, #0x4000	; Coloca en r5 la dirección de inicio para almacenar los resultados
OTRO:	LW r6, 0(r1)			; Carga en r6 el valor almacenado en la dirección apuntada por r1
		SLT r7, r6, r4			; Compara si r6 < 40 = r4, si es así r7 = 1, sino r7 = 0
		BNEZ r7, PROX			; Si r7 != 0 (r6 < 40) salta a la etiqueta 'PROX'
		SW 0(r5), r6			; Almacena el valor de r6 en la dirección apuntada por r5
		ADDI r5, r5, #4			; Incrementa r5 en 4 para apuntar a la siguiente posición de almacenamiento
		ADDI r3, r3, #1			; Incrementa el contador de elementos almacenados en r3
PROX:	ADDI r1, r1, #4			; Incrementa r1 en 4 para apuntar al siguiente elemento
		SUBI r2, r2, #1			; Decrementa el contador r2 en 1
		BNEZ r2, OTRO			; Si r2 != 0, repite el ciclo
		SW 0(r5), r3			; Almacena el número de elementos almacenados en r3
		TRAP 0

; Lo que realiza el programa es copiar todos los elementos de un bloque de memoria de 150 componentes que sean mayores o iguales a 40, a otra ubicación de memoria, y al final almacena en la siguiente posición libre la cantidad de elementos copiados.

; Codigo en directivas para el programa ensamblador.

			.data 0x5000
block:		.word  ...				; Aquí se deben definir o reservar los 150 elementos de memoria que se van a procesar.
			.data 0x4000
result:		.space 604				; reserva de espacio para almacenar los elementos mayores o
									; iguales a 40 (150*4=600 bytes + 4 bytes para almacenar la cantidad)
			.text 0x100				; comienzo del código
main:		ADDI r1, r0, #block	; Coloca en r1 la dirección inicial del bloque de memoria
			ADDI r2, r0, #150		; Inicializa el contador r2 con el valor 150
			ADD r3, r0, r0			; Inicializa el acumulador r3 a 0
			ADDI r4, r0, #40		; Inicializa el límite superior r4 con el valor 40
			ADDI r5, r0, #result	; Coloca en r5 la dirección de inicio para almacenar los resultados
OTRO:		LW r6, 0(r1)			; Carga en r6 el valor almacenado en la dirección apuntada por r1
			SLT r7, r6, r4			; Compara si r6 < 40 = r4
			BNEZ r7, PROX			; Si r7 != 0 (r6 < 40) salta a la etiqueta 'PROX'
			SW 0(r5), r6			; Almacena el valor de r6 en la dirección apuntada por r5
			ADDI r5, r5, #4			; Incrementa r5 en 4 para apuntar a la siguiente posición de almacenamiento
			ADDI r3, r3, #1			; Incrementa el contador de elementos almacenados en r3
PROX:		ADDI r1, r1, #4			; Incrementa r1 en 4 para apuntar al siguiente elemento
			SUBI r2, r2, #1			; Decrementa el contador r2 en 1
			BNEZ r2, OTRO			; Si r2 != 0, repite el ciclo
			SW 0(r5), r3			; Almacena el número de elementos almacenados en r3
			TRAP 0

; Escribir el código en assembler del DLX con las directivas del programa ensamblador que ejecute la
; siguiente tarea: generar un arreglo de datos en memoria a partir de la dirección 0x3500 con los valores
; extraídos de un arreglo de datos de 200 elementos de 4 bytes cargado en memoria a partir de la dirección
; 0x4500 y que cumplan con la condición de ser mayores o iguales a 350. Calcular la cantidad de datos
; generados y guardar el resultado al final de la tabla. Cargar el código a partir de la dirección 100h.

			.data 0x4500
ai:			.word  0...200				; Aquí se deben definir o reservar los 200 elementos de memoria que se van a procesar.
			.data 0x3500
bi:			.space 804				; reserva de espacio para almacenar los elementos mayores o
									; iguales a 350 (200*4=800 bytes + 4 bytes para almacenar la cantidad)
			.text 0x100				; comienzo del código
main:		ADDI r1, r0, #ai		; Coloca en r1 la dirección inicial del bloque de memoria
			ADDI r2, r0, #200		; Inicializa el contador r2 con el valor 200
			ADD r3, r0, r0			; Inicializa el contador r3 a 0
			ADDI r4, r0, #350		; Inicializa el límite superior r4 con el valor 350
			ADDI r5, r0, #bi		; Coloca en r5 la dirección de inicio para almacenar los resultados
ITERA:		LW r6, 0(r1)			; Carga en r6 el valor almacenado en la dirección apuntada por r1
			SLT r7, r6, r4			; Compara si r6 < 350 = r4, si es así r7 = 1, sino r7 = 0
			BNEZ r7, PROX			; Si r7 != 0 (r6 < 350) salta a la etiqueta 'PROX'
			SW 0(r5), r6			; Almacena el valor de r6 en la dirección apuntada por r5
			ADDI r5, r5, #4			; Incrementa r5 en 4 para apuntar a la siguiente posición de almacenamiento
			ADDI r3, r3, #1			; Incrementa el contador de elementos almacenados en r3
PROX:		ADDI r1, r1, #4			; Incrementa r1 en 4 para apuntar al siguiente elemento
			SUBI r2, r2, #1			; Decrementa el contador r2 en 1
			BNEZ r2, ITERA			; Si r2 != 0, repite el ciclo
			SW 0(r5), r3			; Almacena el número de elementos almacenados en r3
			TRAP 0

Otra forma de escribir el código podría ser:

			.data 0x4500
ai:			.word  0...200				; Aquí se deben definir o reservar los 200 elementos de memoria que se van a procesar.
			.data 0x3500
bi:			.space 804				; reserva de espacio para almacenar los elementos mayores o iguales a 350 (200*4=800 bytes + 4 bytes para almacenar la cantidad)
			.text 0x100				; comienzo del código
main:		ADDI r1, r0, #ai		; Coloca en r1 la dirección inicial del bloque de memoria
			ADDI r2, r0, #200		; Inicializa el contador r2 con el valor 200
			ADD r3, r0, r0			; Inicializa el contador r3 a 0
			ADDI r4, r0, #350		; Inicializa el límite superior r4 con el valor 350
			ADDI r5, r0, #bi		; Coloca en r5 la dirección de inicio para almacenar los resultados
ITERA:		LW r6, 0(r1)			; Carga en r6 el valor almacenado en la dirección apuntada por r1
			ADDI r1, r1, #4			; Incrementa r1 en 4 para apuntar al siguiente elemento
			SUBI r2, r2, #1			; Decrementa el contador r2 en 1
			SGE r7, r6, r4			; Compara si r6 >= 350 = r4, si es así r7 = 1, sino r7 = 0
			BEQZ r7, PROX			; Si r7 == 0 (r6 < 350) salta a la etiqueta 'PROX'
			SW 0(r5), r6			; Almacena el valor de r6 en la dirección apuntada por r5
			ADDI r5, r5, #4			; Incrementa r5 en 4 para apuntar a la siguiente posición de almacenamiento
			ADDI r3, r3, #1			; Incrementa el contador de elementos almacenados en r3
PROX:		BNEZ r2, ITERA			; Si r2 != 0, repite el ciclo
			SW 0(r5), r3			; Almacena el número de elementos almacenados en r3
			TRAP 0