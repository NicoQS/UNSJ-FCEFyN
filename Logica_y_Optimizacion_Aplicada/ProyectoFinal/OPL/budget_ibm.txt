// budget_tuples_with_csv.mod

// ------------------------------------------------------------
//  Importación de datos desde CSV:
//    • parameters.csv  → dataset "parameters"
//    • MinBal.csv      → dataset "MinBal"
//    • Projects.csv    → dataset "Projects"
//    • MustTakeOne.csv → dataset "MustTakeOne"
// ------------------------------------------------------------

// 1) Parámetros escalares
tuple ParamRow { 
  string Parameter; 
  float Value; 
}
{ParamRow} parameters = ...;

int T             = ftoi(sum(r in parameters: r.Parameter=="T") r.Value);
int NbMustTakeOne = ftoi(sum(r in parameters: r.Parameter=="NbMustTakeOne") r.Value);
float Rate        = sum(r in parameters: r.Parameter=="Rate") r.Value;
float InitBal     = sum(r in parameters: r.Parameter=="InitBal") r.Value;

// 2) Definir rango
range Periods = 1..T;

// 3) MinBal
tuple MinBalRow { 
  int Period; 
  int MinBal; 
}
{MinBalRow} MinBal = ...;

float MinBalArr[t in Periods] =
  sum(m in MinBal: m.Period==t) m.MinBal;

// 4) Proyectos (NOTA: el dataset debe llamarse "Projects", igual que el archivo)
tuple ProjectRow {
  string name;
  int setupCost_1; 
  int setupCost_2; 
  int setupCost_3;
  int reward_1;  
  int reward_2;  
  int reward_3;
}
{ProjectRow} Projects = ...;

// 5) Must-take-one
tuple MustTakeRow { 
  int group; 
  string project; 
}
{MustTakeRow} MustTakeOne = ...;

// 6) Variables de decisión
dvar float   Bal[0..T];
dvar boolean doProj[Projects][Periods];
dvar boolean SelectedProj[Projects][Periods];

// 7) Objetivo
maximize 
  Bal[T] / pow(1+Rate, T) - Bal[0];

// 8) Restricciones
subject to {

  // Saldo inicial
  Bal[0] == InitBal;

  // Flujo de caja
  forall(t in Periods)
    CtBalance: 
    Bal[t] ==
      (1+Rate) * (
        Bal[t-1]
        - sum(p in Projects) 
            (t==1 ? p.setupCost_1 : (t==2 ? p.setupCost_2 : p.setupCost_3)) * doProj[p][t]
        + sum(p in Projects) 
            (t==1 ? p.reward_1 : (t==2 ? p.reward_2 : p.reward_3)) * SelectedProj[p][t]
      );

  // Mínimo saldo
  forall(t in Periods)
    CtMinBal:
    Bal[t] >= MinBalArr[t];

  // SelectedProj en función de doProj
  forall(p in Projects, t in Periods)
    CtSelected:
    SelectedProj[p][t] == (t==1 ? 0 : sum(s in 1..t-1) doProj[p][s]);

  // Cada proyecto, a lo sumo una vez
  forall(p in Projects)
    CtOnce:
    sum(t in Periods) doProj[p][t] <= 1;

  // Must‐take‐one por grupo
  forall(g in 1..NbMustTakeOne)
    CtMustTake:
    sum(p in Projects, m in MustTakeOne:
          m.group==g && m.project==p.name)
      SelectedProj[p][T]
    == 1;
}
// ------------------------------------------------------------
// DEFINICIÓN DE TUPLAS DE SALIDA
// ------------------------------------------------------------

// Tupla para el resultado general
tuple SolutionSummary {
  float NPV;
  float FinalBalance;
  float InitialBalance;
  int TotalProjects;
  string Status;
}

// Tupla para proyectos seleccionados
tuple SelectedProjectDetail {
  string ProjectName;
  int Period;
  int SetupCost;
  int Reward;
  float NPV_Contribution;
}

// Tupla para saldos por período
tuple BalanceDetail {
  int Period;
  float Balance;
  float DiscountedBalance;
}


// Declaración de conjuntos de salida
{SolutionSummary} SolutionResults = {};
{SelectedProjectDetail} SelectedProjectsOutput = {};
{BalanceDetail} BalanceResults = {};

// 9) Post-procesamiento: Poblar tuplas de salida
execute POPULATE_OUTPUT_TUPLES {
  if (cplex.getCplexStatus() == 1) {
    
    // 1) Resumen de la solución
    var totalProjectsSelected = 0;
    for(var p in Projects) {
      for(var t in Periods) {
        if(doProj[p][t].solutionValue > 0.5) {
          totalProjectsSelected++;
          break; // Solo contar cada proyecto una vez
        }
      }
    }
    
    SolutionResults.add(
      cplex.getObjValue(),                    // NPV
      Bal[T].solutionValue,                   // FinalBalance
      Bal[0].solutionValue,                   // InitialBalance
      totalProjectsSelected,                  // TotalProjects
      "OPTIMAL"                               // Status
    );

    // 2) Detalles de proyectos seleccionados
    for(var p in Projects) {
      for(var t in Periods) {
        if(doProj[p][t].solutionValue > 0.5) {
          var setupCost = (t==1 ? p.setupCost_1 : (t==2 ? p.setupCost_2 : p.setupCost_3));
          
          // Calcular recompensa total (sin descuento para simplificar)
          var totalReward = 0;
          for(var future_t = t+1; future_t <= T; future_t++) {
            var reward = (future_t==1 ? p.reward_1 : (future_t==2 ? p.reward_2 : p.reward_3));
            if(SelectedProj[p][future_t].solutionValue > 0.5) {
              totalReward += reward;
            }
          }
          
          SelectedProjectsOutput.add(
            p.name,                           // ProjectName
            t,                                // Period
            setupCost,                        // SetupCost
            totalReward,                      // Reward
            totalReward - setupCost           // NPV_Contribution (simplificado)
          );
        }
      }
    }

    // 3) Detalles de saldos por período
    for(var t = 0; t <= T; t++) {
      BalanceResults.add(
        t,                                    // Period
        Bal[t].solutionValue,                // Balance
        Bal[t].solutionValue                 // DiscountedBalance (mismo valor para simplificar)
      );
    }

    // Mostrar resultados en consola también
    writeln("=== RESULTADOS DE CAPITAL BUDGETING ===");
    writeln("NPV = ", cplex.getObjValue());
    writeln("Total de proyectos seleccionados: ", totalProjectsSelected);
    writeln();

    writeln("Proyectos seleccionados:");
    for(var p in Projects) {
      var selected = false;
      for(var t in Periods) {
        if(doProj[p][t].solutionValue > 0.5) {
          if(!selected) {
            write("  - ", p.name, " en periodo: ", t);
            selected = true;
          }
        }
      }
      if(selected) writeln("");
    }
    writeln();

    writeln("Saldo al final de cada periodo:");
    for(var t = 0; t <= T; t++) {
      writeln("  Bal[", t, "] = ", Bal[t].solutionValue);
    }
    
  } else {
    // Si no hay solución óptima
    SolutionResults.add(
      0,                                      // NPV
      0,                                      // FinalBalance  
      InitBal,                                // InitialBalance
      0,                                      // TotalProjects
      "NO_SOLUTION"                           // Status
    );
    
    writeln("No se encontró solución óptima. Estado CPLEX: ", cplex.getCplexStatus());
  }
}